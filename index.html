<!DOCTYPE html>
<html lang="zh-HK">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>å¿ƒæƒ…æ—¥è¨˜ (Universal)</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=cwTeXYen&display=swap" rel="stylesheet">

<style>
    /* --- SIMPLE ROBUST STYLING --- */
    body { font-family: 'cwTeXYen', sans-serif; background: #fff8e1; margin: 0; padding: 15px; user-select: none; }
    .container { max-width: 800px; margin: 0 auto; background: white; border: 4px dashed #ff9800; border-radius: 20px; padding: 15px; }
    h1 { text-align: center; color: #ff9800; margin: 5px 0 15px 0; }
    
    .section { background: #fff; border: 2px solid #eee; border-radius: 15px; padding: 15px; margin-bottom: 20px; }
    h3 { margin-top: 0; color: #5d4037; font-size: 1.2rem; }

    /* TEXTBOX */
    textarea { 
        width: 100%; padding: 15px; border: 2px solid #ddd; border-radius: 10px; 
        font-size: 1.3rem; font-family: inherit; box-sizing: border-box; 
        background: #fafafa; outline: none; min-height: 120px;
    }
    textarea:focus { border-color: #ff9800; background: #fffde7; }

    /* BIG BUTTONS */
    .btn { 
        width: 100%; padding: 15px; margin: 5px 0; border: none; border-radius: 10px; 
        font-size: 1.2rem; cursor: pointer; color: white; display: flex; 
        justify-content: center; align-items: center; gap: 10px; font-weight: bold; 
    }
    .btn-mic { background: #ff5252; box-shadow: 0 4px 0 #b71c1c; }
    .btn-mic.active { background: #d32f2f; animation: pulse 1s infinite; }
    .btn-read { background: #2196f3; box-shadow: 0 4px 0 #0d47a1; }
    .btn-save { background: #4caf50; box-shadow: 0 4px 0 #1b5e20; }

    /* DRAWING & TOOLS */
    .tool-row { display: flex; gap: 5px; margin-bottom: 10px; overflow-x: auto; }
    .tool-btn { 
        flex: 1; min-width: 60px; padding: 10px; background: white; border: 2px solid #eee; 
        border-radius: 10px; text-align: center; font-size: 1.2rem; 
    }
    .tool-btn.active { background: #ffe0b2; border-color: #ff9800; transform: translateY(2px); }
    
    canvas { border: 2px solid #ccc; border-radius: 10px; width: 100%; height: auto; background: white; touch-action: none; }
    
    #debugLog { font-size: 0.8rem; color: #999; margin-top: 20px; border-top: 1px solid #ccc; padding-top: 5px; }

    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }
</style>
</head>
<body>

<div class="container">
    <h1>ğŸŒ å¿ƒæƒ…æ—¥è¨˜</h1>

    <div class="section">
        <h3>ğŸ“… æ—¥æœŸèˆ‡åœ°é»</h3>
        <input type="date" id="dateInput" style="font-size:1.2rem; padding:10px; width:100%; box-sizing:border-box; margin-bottom:10px;">
        <select id="locationSelect" style="font-size:1.2rem; padding:10px; width:100%;">
            <option value="å­¸æ ¡">ğŸ« å­¸æ ¡</option>
            <option value="å±‹ä¼">ğŸ  å±‹ä¼</option>
            <option value="å…¬åœ’">ğŸŒ³ å…¬åœ’</option>
        </select>
    </div>

    <div class="section">
        <h3>ğŸ—£ï¸ äº‹æƒ… (èªéŸ³è¼¸å…¥)</h3>
        
        <button id="btnMic" class="btn btn-mic" onclick="toggleMic()">
            <i class="fas fa-microphone"></i> æŒ‰æ­¤èªªè©± / åœæ­¢
        </button>

        <textarea id="textBox" placeholder="è«‹è®€å‡ºå…§å®¹..."></textarea>

        <button class="btn btn-read" onclick="speakText()">
            <i class="fas fa-volume-up"></i> æœ—è®€æª¢æŸ¥
        </button>
    </div>

    <div class="section">
        <h3>ğŸ¨ ç•«æ¿</h3>
        <div class="tool-row">
            <button class="tool-btn active" onclick="setMode('brush', this)">ğŸ–Œï¸</button>
            <button class="tool-btn" onclick="setMode('eraser', this)">ğŸ§½</button>
            <button class="tool-btn" onclick="clearCanvas()">ğŸ—‘ï¸</button>
            <button class="tool-btn" style="background:black;" onclick="setColor('black')"></button>
            <button class="tool-btn" style="background:red;" onclick="setColor('red')"></button>
            <button class="tool-btn" style="background:blue;" onclick="setColor('blue')"></button>
        </div>
        <canvas id="canvas" width="800" height="400"></canvas>
    </div>

    <button class="btn btn-save" onclick="saveData()">ğŸ’¾ å„²å­˜æª”æ¡ˆ</button>
    
    <div id="debugLog">ç³»çµ±ç‹€æ…‹: æº–å‚™å°±ç·’</div>
</div>

<script>
    // --- 1. CORE VARIABLES ---
    const dateInput = document.getElementById('dateInput');
    const textBox = document.getElementById('textBox');
    const btnMic = document.getElementById('btnMic');
    const debugLog = document.getElementById('debugLog');
    
    dateInput.valueAsDate = new Date();

    // --- 2. UNIVERSAL SPEECH ENGINE ---
    let recognition;
    let isListening = false;
    let memoryText = ""; // The "Anchor" text

    function log(msg) {
        debugLog.innerText = "ç‹€æ…‹: " + msg;
        console.log(msg);
    }

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        
        // CRITICAL SETTINGS FOR MOBILE
        recognition.lang = 'zh-HK';
        recognition.continuous = true;  // Try to keep open
        recognition.interimResults = true; // Essential for "Instant" feel
        recognition.maxAlternatives = 1;

        recognition.onstart = function() {
            isListening = true;
            btnMic.classList.add('active');
            btnMic.innerHTML = '<i class="fas fa-stop"></i> æ”¶éŸ³ä¸­... (é»æ“Šåœæ­¢)';
            
            // ANCHOR: Lock current text into memory immediately
            memoryText = textBox.value;
            // Add space logic
            if (memoryText.length > 0 && ![' ', 'ï¼Œ', 'ã€‚'].includes(memoryText.slice(-1))) {
                memoryText += " ";
            }
            log("æ”¶éŸ³é–‹å§‹ (Base: " + memoryText.length + " chars)");
        };

        recognition.onend = function() {
            isListening = false;
            btnMic.classList.remove('active');
            btnMic.innerHTML = '<i class="fas fa-microphone"></i> æŒ‰æ­¤èªªè©± / åœæ­¢';
            
            // SYNC: Update memory to match what is visually in the box
            memoryText = textBox.value; 
            log("æ”¶éŸ³åœæ­¢ (Saved)");
        };

        recognition.onresult = function(event) {
            let interimTrans = '';
            let finalTrans = '';

            // Process all results in the current session
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    finalTrans += event.results[i][0].transcript;
                } else {
                    interimTrans += event.results[i][0].transcript;
                }
            }

            // FORCE WRITE: Anchor + Final + Interim
            // This overwrites the box completely every few milliseconds
            if (finalTrans || interimTrans) {
                // Update the memory anchor with finalized text
                memoryText += finalTrans; 
                // Display memory + current unstable text
                textBox.value = memoryText + interimTrans;
                // Auto-scroll
                textBox.scrollTop = textBox.scrollHeight;
            }
        };

        recognition.onerror = function(event) {
            log("Error: " + event.error);
            // If mobile kills it, reset UI so user can tap again
            if (event.error === 'not-allowed' || event.error === 'service-not-allowed') {
                alert("è«‹æª¢æŸ¥ç€è¦½å™¨éº¥å…‹é¢¨æ¬Šé™ (Please check Mic permissions)");
            }
            isListening = false;
            btnMic.classList.remove('active');
        };
    } else {
        alert("æ­¤ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³è¼¸å…¥ (Browser not supported)");
    }

    function toggleMic() {
        if (!recognition) return;
        if (isListening) {
            recognition.stop();
        } else {
            // Safety: Update anchor one last time before starting
            memoryText = textBox.value;
            recognition.start();
        }
    }

    // --- 3. DRAWING ENGINE ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = "white"; ctx.fillRect(0,0,800,400); 
    ctx.lineCap = "round"; ctx.lineJoin = "round";
    
    let isDrawing = false;
    let brushColor = "black";
    let brushSize = 5;

    function setMode(mode, btn) {
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        if(btn) btn.classList.add('active');
        
        if (mode === 'eraser') {
            ctx.globalCompositeOperation = "destination-out";
            brushSize = 30;
        } else {
            ctx.globalCompositeOperation = "source-over";
            brushSize = 5;
            ctx.strokeStyle = brushColor;
        }
    }

    function setColor(color) {
        brushColor = color;
        setMode('brush', null); // Reset to brush mode
        ctx.strokeStyle = color;
    }

    function clearCanvas() {
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = "white"; ctx.fillRect(0,0,800,400);
        ctx.strokeStyle = brushColor;
    }

    // Touch Handling (Universal)
    function getPos(e) {
        const r = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
            x: (clientX - r.left) * (canvas.width / r.width),
            y: (clientY - r.top) * (canvas.height / r.height)
        };
    }

    function startDraw(e) { e.preventDefault(); isDrawing=true; ctx.beginPath(); const p=getPos(e); ctx.moveTo(p.x, p.y); ctx.lineWidth=brushSize; }
    function moveDraw(e) { if(!isDrawing) return; e.preventDefault(); const p=getPos(e); ctx.lineTo(p.x, p.y); ctx.stroke(); }
    function endDraw() { isDrawing=false; }

    canvas.addEventListener('mousedown', startDraw); canvas.addEventListener('mousemove', moveDraw); canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('touchstart', startDraw, {passive:false}); canvas.addEventListener('touchmove', moveDraw, {passive:false}); canvas.addEventListener('touchend', endDraw);

    // --- 4. EXPORT & TTS ---
    function speakText() {
        if(!textBox.value) return;
        const u = new SpeechSynthesisUtterance(textBox.value);
        u.lang = 'zh-HK';
        window.speechSynthesis.speak(u);
    }

    function saveData() {
        const txt = textBox.value;
        const date = dateInput.value;
        const loc = document.getElementById('locationSelect').value;
        
        // CSV
        const csv = `\uFEFFæ—¥æœŸ,åœ°é»,å…§å®¹\n${date},${loc},${txt}`;
        const blob = new Blob([csv], {type:'text/csv'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `Diary_${date}.csv`;
        a.click();

        // IMG
        setTimeout(() => {
            const link = document.createElement('a');
            link.download = `Drawing_${date}.jpg`;
            link.href = canvas.toDataURL('image/jpeg');
            link.click();
        }, 500);
    }
</script>
</body>
</html>