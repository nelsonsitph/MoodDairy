<!DOCTYPE html>
<html lang="zh-HK">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>å¿ƒæƒ…æ—¥è¨˜ (Accumulate Ver.)</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css2?family=cwTeXYen&display=swap" rel="stylesheet">

<style>
    /* --- STYLES --- */
    :root { --primary: #ff9800; --bg: #fff8e1; --text: #5d4037; --mic-active: #d32f2f; }
    body { font-family: 'cwTeXYen', sans-serif; background-color: var(--bg); color: var(--text); margin: 0; padding: 15px; user-select: none; -webkit-tap-highlight-color: transparent; }
    .container { max-width: 800px; margin: 0 auto; background: white; border: 4px dashed var(--primary); border-radius: 20px; padding: 15px; box-shadow: 0 10px 0 rgba(0,0,0,0.1); }
    h1 { text-align: center; color: var(--primary); margin-top: 5px; }
    .section { background: #fff; border: 2px solid #eee; border-radius: 15px; padding: 15px; margin-bottom: 20px; }
    
    /* TEXT AREA - The "Screen" */
    textarea { 
        width: 100%; padding: 15px; border: 3px solid #ddd; border-radius: 12px; 
        font-size: 1.4rem; font-family: inherit; box-sizing: border-box; 
        background: #fafafa; outline: none; min-height: 150px;
        transition: border 0.3s;
    }
    textarea:focus { border-color: var(--primary); }
    /* Visual feedback when Mic is on */
    textarea.recording { border-color: #ff5252; background: #fff5f5; }

    /* BUTTONS */
    .btn { 
        width: 100%; padding: 15px; margin: 5px 0; border: none; border-radius: 12px; 
        font-size: 1.3rem; cursor: pointer; color: white; display: flex; 
        justify-content: center; align-items: center; gap: 10px; font-weight: bold;
    }
    .btn-mic { background: #ff5252; box-shadow: 0 5px 0 #b71c1c; }
    .btn-mic.active { background: var(--mic-active); animation: pulse 1.5s infinite; }
    .btn-read { background: #42a5f5; box-shadow: 0 5px 0 #1565c0; font-size: 1.1rem; }
    .btn-save { background: #4caf50; box-shadow: 0 5px 0 #2e7d32; font-size: 1.2rem; margin-top: 15px; }
    .btn:active { transform: translateY(4px); box-shadow: none !important; }

    /* DATE & LOC */
    input, select { width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 10px; font-size: 1.2rem; margin-bottom: 10px; box-sizing: border-box; }

    /* DRAWING */
    .tool-row { display: flex; gap: 5px; margin-bottom: 10px; overflow-x: auto; }
    .tool-btn { min-width: 50px; height: 50px; background: white; border: 2px solid #eee; border-radius: 50%; font-size: 1.5rem; cursor: pointer; }
    canvas { border: 2px solid #ccc; border-radius: 10px; width: 100%; height: auto; background: white; touch-action: none; }

    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }
</style>
</head>
<body>

<div class="container">
    <h1>ğŸŒ å¿ƒæƒ…æ—¥è¨˜</h1>

    <div class="section">
        <input type="date" id="dateInput">
        <select id="locationSelect">
            <option value="å­¸æ ¡">ğŸ« å­¸æ ¡</option>
            <option value="å±‹ä¼">ğŸ  å±‹ä¼</option>
            <option value="å…¬åœ’">ğŸŒ³ å…¬åœ’</option>
        </select>
    </div>

    <div class="section">
        <h3>ğŸ—£ï¸ äº‹æƒ… (èªéŸ³è¼¸å…¥)</h3>
        
        <button id="btnMic" class="btn btn-mic" onclick="toggleMic()">
            <i class="fas fa-microphone"></i> æŒ‰æ­¤èªªè©±
        </button>

        <textarea id="textBox" placeholder="è«‹æŒ‰æŒ‰éˆ•ï¼Œç„¶å¾Œè®€å‡ºå¥å­..."></textarea>

        <button class="btn btn-read" onclick="speakText()">
            <i class="fas fa-volume-up"></i> æœ—è®€æª¢æŸ¥
        </button>
    </div>

    <div class="section">
        <h3>ğŸ¨ ç•«æ¿</h3>
        <div class="tool-row">
            <button class="tool-btn" onclick="setMode('brush')">ğŸ–Œï¸</button>
            <button class="tool-btn" onclick="setMode('eraser')">ğŸ§½</button>
            <button class="tool-btn" onclick="clearCanvas()">ğŸ—‘ï¸</button>
            <button class="tool-btn" style="background:black;" onclick="setColor('black')"></button>
            <button class="tool-btn" style="background:#e91e63;" onclick="setColor('#e91e63')"></button>
            <button class="tool-btn" style="background:#2196f3;" onclick="setColor('#2196f3')"></button>
        </div>
        <canvas id="canvas" width="800" height="400"></canvas>
    </div>

    <button class="btn btn-save" onclick="saveData()">ğŸ’¾ å„²å­˜æ—¥è¨˜</button>
</div>

<audio id="popSound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg"></audio>

<script>
    // --- 1. SETUP ---
    document.getElementById('dateInput').valueAsDate = new Date();
    const textBox = document.getElementById('textBox');
    const btnMic = document.getElementById('btnMic');
    
    function playPop() { document.getElementById('popSound').play().catch(()=>{}); }

    // --- 2. ACCUMULATION SPEECH LOGIC ---
    let recognition;
    let isListening = false;
    let final_transcript = ""; // This is our Permanent Memory

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        
        recognition.lang = 'zh-HK';
        recognition.continuous = false; // MOBILE FIX: Do not force continuous. Let it stop naturally.
        recognition.interimResults = true; // Show words as they are spoken

        // A. START: Load Memory
        recognition.onstart = function() {
            isListening = true;
            playPop();
            btnMic.classList.add('active');
            btnMic.innerHTML = '<i class="fas fa-stop"></i> æ”¶éŸ³ä¸­... (é»æ“Šåœæ­¢)';
            textBox.classList.add('recording');
            
            // 1. READ MEMORY: Grab whatever is currently in the box
            final_transcript = textBox.value;
            
            // 2. SMART SPACE: If there is text, add a space/punctuation buffer
            if (final_transcript.length > 0) {
                // Check if last char is not a punctuation mark
                let lastChar = final_transcript.slice(-1);
                if (![' ', 'ï¼Œ', 'ã€‚', '\n'].includes(lastChar)) {
                    final_transcript += " ";
                }
            }
        };

        // B. END: Save State
        recognition.onend = function() {
            isListening = false;
            btnMic.classList.remove('active');
            btnMic.innerHTML = '<i class="fas fa-microphone"></i> æŒ‰æ­¤èªªè©±';
            textBox.classList.remove('recording');
            
            // 3. SAVE MEMORY: Ensure the variable matches the visual box
            final_transcript = textBox.value; 
        };

        // C. RESULT: Accumulate
        recognition.onresult = function(event) {
            let interim_transcript = '';
            let new_final = '';

            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    new_final += event.results[i][0].transcript;
                } else {
                    interim_transcript += event.results[i][0].transcript;
                }
            }

            // 4. ACCUMULATE LOGIC:
            // Memory (Previous Sentences) + New Final (Just finished)
            if (new_final) {
                final_transcript += new_final;
            }

            // 5. DISPLAY: 
            // Memory + Interim (What is being said right now)
            textBox.value = final_transcript + interim_transcript;
            
            // Auto scroll to bottom
            textBox.scrollTop = textBox.scrollHeight;
        };

        recognition.onerror = function(event) {
            // If mobile kills it, just stop quietly
            isListening = false;
            btnMic.classList.remove('active');
            textBox.classList.remove('recording');
        };
    } else {
        alert("æ­¤ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³åŠŸèƒ½ (Browser Not Supported)");
    }

    function toggleMic() {
        if (!recognition) return;
        if (isListening) {
            recognition.stop();
        } else {
            // Always reload memory from box before starting
            final_transcript = textBox.value; 
            recognition.start();
        }
    }

    // --- 3. DRAWING ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = "white"; ctx.fillRect(0,0,800,400); ctx.lineCap = "round"; ctx.lineJoin = "round";
    let isDrawing = false; let brushColor = "black"; let brushSize = 5;

    function setMode(mode) {
        if(mode==='eraser'){ ctx.globalCompositeOperation="destination-out"; brushSize=30; }
        else{ ctx.globalCompositeOperation="source-over"; ctx.strokeStyle=brushColor; brushSize=5; }
    }
    function setColor(c) { brushColor=c; setMode('brush'); }
    function clearCanvas() { ctx.globalCompositeOperation="source-over"; ctx.fillStyle="white"; ctx.fillRect(0,0,800,400); }

    function getPos(e) {
        const r = canvas.getBoundingClientRect();
        const x = e.touches ? e.touches[0].clientX : e.clientX;
        const y = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: (x-r.left)*(800/r.width), y: (y-r.top)*(400/r.height) };
    }
    function start(e) { e.preventDefault(); isDrawing=true; ctx.beginPath(); const p=getPos(e); ctx.moveTo(p.x,p.y); ctx.lineWidth=brushSize; }
    function move(e) { if(!isDrawing) return; e.preventDefault(); const p=getPos(e); ctx.lineTo(p.x,p.y); ctx.stroke(); }
    function end() { isDrawing=false; }
    canvas.addEventListener('mousedown', start); canvas.addEventListener('mousemove', move); canvas.addEventListener('mouseup', end);
    canvas.addEventListener('touchstart', start, {passive:false}); canvas.addEventListener('touchmove', move, {passive:false}); canvas.addEventListener('touchend', end);

    // --- 4. EXPORT ---
    function speakText() { 
        if(!textBox.value) return;
        const u = new SpeechSynthesisUtterance(textBox.value); 
        u.lang='zh-HK'; 
        window.speechSynthesis.speak(u); 
    }
    
    function saveData() {
        const d = document.getElementById('dateInput').value;
        const l = document.getElementById('locationSelect').value;
        const t = textBox.value;
        const csv = `\uFEFFæ—¥æœŸ,åœ°é»,å…§å®¹\n${d},${l},${t}`;
        const a = document.createElement('a'); a.href=URL.createObjectURL(new Blob([csv],{type:'text/csv'})); a.download=`Diary_${d}.csv`; a.click();
        setTimeout(()=>{
            const a2 = document.createElement('a'); a2.href=canvas.toDataURL('image/jpeg'); a2.download=`Drawing_${d}.jpg`; a2.click();
        },500);
    }
</script>
</body>
</html>